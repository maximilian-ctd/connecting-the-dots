---
// ValueProposition-Komponente für ConnectingTheDots
// Features mit Cards und ConnectingDots-Effekt
---

<section class="bg-secondary py-20 px-4 relative overflow-hidden">
  <!-- Connecting dots background -->
  <div class="absolute inset-0 opacity-30">
    <!-- ConnectingDots wird hier als Hintergrund verwendet -->
  </div>
  
  <div class="max-w-7xl mx-auto relative z-10">
    <div class="text-center mb-16">
      <h2 class="text-3xl lg:text-4xl mb-6">
        Why Choose ConnectingTheDots?
      </h2>
      <p class="text-lg text-muted-foreground max-w-2xl mx-auto">
        Proven methodology for minimal risk, maximum insights.
      </p>
    </div>
    
    <div class="grid md:grid-cols-3 gap-8">
      <!-- Feature 1: 3-Step Model -->
      <div class="feature-card opacity-0" data-index="0">
        <div class="card-wrapper">
          <div class="bg-white border-0 shadow-sm rounded-2xl hover:shadow-xl transition-shadow relative overflow-hidden">
            <!-- Animated green dots canvas -->
            <canvas class="animated-dots-canvas" data-card-index="0"></canvas>
            <div class="p-8 text-center relative z-10">
              <div class="icon-wrapper w-16 h-16 bg-accent rounded-2xl flex items-center justify-center mx-auto mb-6">
                <svg class="w-8 h-8 text-accent-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                </svg>
              </div>
              <h3 class="text-xl mb-4">3-Step Model</h3>
              <p class="text-muted-foreground leading-relaxed">
                Structured validation process for quick results.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Feature 2: Expert Network -->
      <div class="feature-card opacity-0" data-index="1">
        <div class="card-wrapper">
          <div class="bg-white border-0 shadow-sm rounded-2xl hover:shadow-xl transition-shadow relative overflow-hidden">
            <!-- Animated green dots canvas -->
            <canvas class="animated-dots-canvas" data-card-index="1"></canvas>
            <div class="p-8 text-center relative z-10">
              <div class="icon-wrapper w-16 h-16 bg-accent rounded-2xl flex items-center justify-center mx-auto mb-6">
                <svg class="w-8 h-8 text-accent-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path>
                </svg>
              </div>
              <h3 class="text-xl mb-4">Expert Network</h3>
              <p class="text-muted-foreground leading-relaxed">
                Industry specialists and validated market insights.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Feature 3: No Internal Resources Required -->
      <div class="feature-card opacity-0" data-index="2">
        <div class="card-wrapper">
          <div class="bg-white border-0 shadow-sm rounded-2xl hover:shadow-xl transition-shadow relative overflow-hidden">
            <!-- Animated green dots canvas -->
            <canvas class="animated-dots-canvas" data-card-index="2"></canvas>
            <div class="p-8 text-center relative z-10">
              <div class="icon-wrapper w-16 h-16 bg-accent rounded-2xl flex items-center justify-center mx-auto mb-6">
                <svg class="w-8 h-8 text-accent-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
              </div>
              <h3 class="text-xl mb-4">No Internal Resources Required</h3>
              <p class="text-muted-foreground leading-relaxed">
                Focus on building while we handle validation.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  // Animated green dots for each card
  class AnimatedDots {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private dots: Array<{
      x: number;
      y: number;
      vx: number;
      vy: number;
      radius: number;
      pulse: number;
      pulseSpeed: number;
    }>;
    private animationFrameId: number;
    private width: number;
    private height: number;
    private color: string = '#7be0b7'; // Accent color

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      this.ctx = ctx;
      this.dots = [];
      this.animationFrameId = 0;
      this.width = 0;
      this.height = 0;
      
      this.init();
    }

    private init() {
      this.resize();
      this.createDots();
      this.animate();
      
      window.addEventListener('resize', () => {
        this.resize();
        this.createDots();
      });
    }

    private resize() {
      const rect = this.canvas.getBoundingClientRect();
      this.width = rect.width;
      this.height = rect.height;
      this.canvas.width = this.width * window.devicePixelRatio;
      this.canvas.height = this.height * window.devicePixelRatio;
      this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    private createDots() {
      this.dots = [];
      const numDots = 8;
      
      for (let i = 0; i < numDots; i++) {
        this.dots.push({
          x: Math.random() * this.width,
          y: Math.random() * this.height,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
          radius: 3 + Math.random() * 2,
          pulse: Math.random() * Math.PI * 2,
          pulseSpeed: 0.02 + Math.random() * 0.02
        });
      }
    }

    private animate = () => {
      this.ctx.clearRect(0, 0, this.width, this.height);
      
      // Update and draw dots
      this.dots.forEach((dot, i) => {
        // Update position
        dot.x += dot.vx;
        dot.y += dot.vy;
        
        // Bounce off edges
        if (dot.x < 0 || dot.x > this.width) dot.vx *= -1;
        if (dot.y < 0 || dot.y > this.height) dot.vy *= -1;
        
        // Keep within bounds
        dot.x = Math.max(0, Math.min(this.width, dot.x));
        dot.y = Math.max(0, Math.min(this.height, dot.y));
        
        // Update pulse
        dot.pulse += dot.pulseSpeed;
        
        // Draw dot with pulse effect
        const pulseSize = 1 + Math.sin(dot.pulse) * 0.3;
        const currentRadius = dot.radius * pulseSize;
        const opacity = 0.6 + Math.sin(dot.pulse) * 0.3;
        
        this.ctx.beginPath();
        this.ctx.arc(dot.x, dot.y, currentRadius, 0, Math.PI * 2);
        this.ctx.fillStyle = this.color;
        this.ctx.globalAlpha = opacity;
        this.ctx.fill();
        this.ctx.globalAlpha = 1;
        
        // Draw connecting lines to nearby dots
        this.dots.slice(i + 1).forEach(otherDot => {
          const dx = dot.x - otherDot.x;
          const dy = dot.y - otherDot.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 80) {
            const lineOpacity = (1 - distance / 80) * 0.2;
            this.ctx.beginPath();
            this.ctx.moveTo(dot.x, dot.y);
            this.ctx.lineTo(otherDot.x, otherDot.y);
            this.ctx.strokeStyle = this.color;
            this.ctx.globalAlpha = lineOpacity;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
            this.ctx.globalAlpha = 1;
          }
        });
      });
      
      this.animationFrameId = requestAnimationFrame(this.animate);
    }

    public destroy() {
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
      }
    }
  }

  function initValueProposition() {
    const featureCards = document.querySelectorAll('.feature-card');
    
    // Initialize animated dots for each card
    const dotAnimations: AnimatedDots[] = [];
    featureCards.forEach((card) => {
      const canvas = card.querySelector('.animated-dots-canvas') as HTMLCanvasElement;
      if (canvas) {
        const animation = new AnimatedDots(canvas);
        dotAnimations.push(animation);
      }
    });
    
    // Intersection Observer für Scroll-Animationen
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '-100px'
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if (entry.isIntersecting) {
          const card = entry.target as HTMLElement;
          const delay = parseInt(card.getAttribute('data-index') || '0') * 200;
          
          setTimeout(() => {
            card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
          }, delay);
        }
      });
    }, observerOptions);

    featureCards.forEach((card) => {
      card.style.transform = 'translateY(30px)';
      observer.observe(card);
    });

    // Hover-Effekte für Cards
    featureCards.forEach((card) => {
      const cardWrapper = card.querySelector('.card-wrapper') as HTMLElement;
      const iconWrapper = card.querySelector('.icon-wrapper') as HTMLElement;
      
      if (cardWrapper && iconWrapper) {
        card.addEventListener('mouseenter', () => {
          cardWrapper.style.transform = 'translateY(-10px) scale(1.02)';
          iconWrapper.style.transform = 'rotate(360deg)';
        });
        
        card.addEventListener('mouseleave', () => {
          cardWrapper.style.transform = 'translateY(0) scale(1)';
          iconWrapper.style.transform = 'rotate(0deg)';
        });
      }
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initValueProposition);
  } else {
    initValueProposition();
  }
</script>

<style>
  .feature-card {
    transition: opacity 0.5s ease, transform 0.5s ease;
  }

  .card-wrapper {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .icon-wrapper {
    transition: transform 0.6s ease;
  }

  /* Animated dots canvas */
  .animated-dots-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  /* ConnectingDots Hintergrund-Effekt (vereinfacht) */
  section::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: 
      radial-gradient(circle at 20% 30%, rgba(123, 224, 183, 0.1) 0%, transparent 50%),
      radial-gradient(circle at 80% 70%, rgba(123, 224, 183, 0.1) 0%, transparent 50%),
      radial-gradient(circle at 50% 50%, rgba(123, 224, 183, 0.05) 0%, transparent 50%);
    opacity: 0.3;
    pointer-events: none;
  }
</style>

