---
// ValueProposition-Komponente f체r ConnectingTheDots
// Features mit Cards und ConnectingDots-Effekt
---

<section class="bg-secondary py-20 px-4 relative overflow-hidden">
  <!-- Connecting dots background -->
  <div class="absolute inset-0 opacity-30">
    <!-- ConnectingDots wird hier als Hintergrund verwendet -->
  </div>
  
  <div class="max-w-7xl mx-auto relative z-10">
    <div class="text-center mb-16">
      <h2 class="text-3xl lg:text-4xl mb-6">
        Why Choose ConnectingTheDots?
      </h2>
      <p class="text-lg text-muted-foreground max-w-2xl mx-auto">
        Proven methodology for minimal risk, maximum insights.
      </p>
    </div>
    
    <div class="grid md:grid-cols-3 gap-8">
      <!-- Feature 1: 3-Step Model -->
      <div class="feature-card opacity-0" data-index="0">
        <div class="card-wrapper">
          <div class="bg-white border-0 shadow-sm rounded-2xl hover:shadow-xl transition-shadow relative overflow-hidden">
            <!-- Animated green dots canvas -->
            <canvas class="animated-dots-canvas" data-card-index="0"></canvas>
            <div class="p-8 text-center relative z-10">
              <div class="icon-wrapper w-16 h-16 bg-accent rounded-2xl flex items-center justify-center mx-auto mb-6">
                <svg class="w-8 h-8 text-accent-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                </svg>
              </div>
              <h3 class="text-xl mb-4">3-Step Model</h3>
              <p class="text-muted-foreground leading-relaxed">
                Structured validation process for quick results.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Feature 2: Expert Network -->
      <div class="feature-card opacity-0" data-index="1">
        <div class="card-wrapper">
          <div class="bg-white border-0 shadow-sm rounded-2xl hover:shadow-xl transition-shadow relative overflow-hidden">
            <!-- Animated green dots canvas -->
            <canvas class="animated-dots-canvas" data-card-index="1"></canvas>
            <div class="p-8 text-center relative z-10">
              <div class="icon-wrapper w-16 h-16 bg-accent rounded-2xl flex items-center justify-center mx-auto mb-6">
                <svg class="w-8 h-8 text-accent-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path>
                </svg>
              </div>
              <h3 class="text-xl mb-4">Expert Network</h3>
              <p class="text-muted-foreground leading-relaxed">
                Industry specialists and validated market insights.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Feature 3: No Internal Resources Required -->
      <div class="feature-card opacity-0" data-index="2">
        <div class="card-wrapper">
          <div class="bg-white border-0 shadow-sm rounded-2xl hover:shadow-xl transition-shadow relative overflow-hidden">
            <!-- Animated green dots canvas -->
            <canvas class="animated-dots-canvas" data-card-index="2"></canvas>
            <div class="p-8 text-center relative z-10">
              <div class="icon-wrapper w-16 h-16 bg-accent rounded-2xl flex items-center justify-center mx-auto mb-6">
                <svg class="w-8 h-8 text-accent-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
              </div>
              <h3 class="text-xl mb-4">No Internal Resources Required</h3>
              <p class="text-muted-foreground leading-relaxed">
                Focus on building while we handle validation.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  // Subtle network overlay for each card
  class CardNetwork {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private nodes: Array<{
      type: 'center' | 'satellite';
      x: number;
      y: number;
      radius: number;
      angle: number;
      baseDistance: number;
      baseDistanceX?: number;
      baseDistanceY?: number;
      drift: number;
      phase: number;
      speed: number;
      intensity: number;
      targetIntensity: number;
      nextConnectionTime: number;
    }>;
    private animationFrameId: number;
    private width: number;
    private height: number;
    private time: number;
    private resizeHandler: () => void;
    private accent: string = '#7be0b7';
    private accentSoft: string = 'rgba(123, 224, 183, 0.35)';

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      this.ctx = ctx;
      this.nodes = [];
      this.animationFrameId = 0;
      this.width = 0;
      this.height = 0;
      this.time = 0;
      this.resizeHandler = () => {
        this.resize();
        this.configureNodes();
        this.time = 0;
      };
      
      this.init();
    }

    private init() {
      this.resize();
      this.configureNodes();
      this.animate();
      
      window.addEventListener('resize', this.resizeHandler, { passive: true });
    }

    private resize() {
      const rect = this.canvas.getBoundingClientRect();
      this.width = rect.width;
      this.height = rect.height;
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.canvas.width = this.width * window.devicePixelRatio;
      this.canvas.height = this.height * window.devicePixelRatio;
      this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    private configureNodes() {
      this.nodes = [];
      const size = Math.min(this.width, this.height);
      const centerX = this.width * 0.5;
      const centerY = this.height * 0.46;
      const centerRadius = Math.max(4, Math.min(9, size * 0.1));

      this.nodes.push({
        type: 'center',
        x: centerX,
        y: centerY,
        radius: centerRadius,
        angle: 0,
        baseDistance: 0,
        drift: size * 0.04,
        phase: 0,
        speed: 0.45,
        intensity: 0,
        targetIntensity: 0.7,
        nextConnectionTime: 0
      });

      const satellites = 8;
      const angleOffset = -Math.PI / 2.8;
      for (let i = 0; i < satellites; i++) {
        const angle = angleOffset + (i * (Math.PI * 2)) / satellites;
        const distanceX = (this.width * 0.28) + Math.random() * (this.width * 0.08);
        const distanceY = (this.height * 0.32) + Math.random() * (this.height * 0.08);

        this.nodes.push({
          type: 'satellite',
          x: 0,
          y: 0,
          radius: Math.max(2.2, Math.min(3.6, size * 0.035)),
          angle,
          baseDistance: 0,
          baseDistanceX: distanceX,
          baseDistanceY: distanceY,
          drift: size * 0.07,
          phase: Math.random() * Math.PI * 2,
          speed: 0.6 + Math.random() * 0.25,
          intensity: 0,
          targetIntensity: 0.5 + Math.random() * 0.3,
          nextConnectionTime: this.time + 2 + Math.random() * 2
        });
      }

      const ambientNodes = 4;
      for (let i = 0; i < ambientNodes; i++) {
        const angle = Math.random() * Math.PI * 2;
        this.nodes.push({
          type: 'satellite',
          x: 0,
          y: 0,
          radius: Math.max(1.8, Math.min(3, size * 0.028)),
          angle,
          baseDistance: size * (0.25 + Math.random() * 0.4),
          drift: size * 0.1,
          phase: Math.random() * Math.PI * 2,
          speed: 0.4 + Math.random() * 0.2,
          intensity: 0,
          targetIntensity: 0.3 + Math.random() * 0.3,
          nextConnectionTime: this.time + 1.5 + Math.random() * 3
        });
      }
    }

    private animate = () => {
      this.time += 0.01;
      this.ctx.clearRect(0, 0, this.width, this.height);
      
      if (this.nodes.length === 0) {
        this.animationFrameId = requestAnimationFrame(this.animate);
        return;
      }

      const center = this.nodes[0];
      const wobbleX = Math.sin(this.time * center.speed) * center.drift;
      const wobbleY = Math.cos(this.time * (center.speed * 0.8)) * center.drift;
      center.x = this.width * 0.52 + wobbleX;
      center.y = this.height * 0.48 + wobbleY;
      center.intensity += (center.targetIntensity - center.intensity) * 0.02;

      this.nodes.slice(1).forEach((node, index) => {
        const angle = node.angle + Math.sin(this.time * 0.4 + node.phase) * 0.12;
        const delta = Math.sin(this.time * node.speed + node.phase) * node.drift;
        const baseDistance = node.baseDistance + delta;

        if (node.baseDistanceX !== undefined && node.baseDistanceY !== undefined) {
          const distanceX = node.baseDistanceX + delta * 0.6;
          const distanceY = node.baseDistanceY + delta * 0.6;
          node.x = center.x + Math.cos(angle) * distanceX;
          node.y = center.y + Math.sin(angle) * distanceY;
        } else {
          node.x = center.x + Math.cos(angle) * baseDistance;
          node.y = center.y + Math.sin(angle) * baseDistance;
        }

        node.intensity += (node.targetIntensity - node.intensity) * 0.025;
        if (this.time > node.nextConnectionTime) {
          node.targetIntensity = 0.4 + Math.random() * 0.4;
          node.nextConnectionTime = this.time + 2.5 + Math.random() * 3;
        }
      });

      this.drawConnections(center);
      this.drawNodes();
      
      this.animationFrameId = requestAnimationFrame(this.animate);
    }

    private drawConnections(center: typeof this.nodes[0]) {
      this.ctx.save();
      this.ctx.lineCap = 'round';
      const timeFactor = (Math.sin(this.time * 0.6) + 1) / 2;

      this.nodes.slice(1).forEach((node, index, arr) => {
        const intensity = Math.min(1, (node.intensity + center.intensity) / 2);
        const gradient = this.ctx.createLinearGradient(center.x, center.y, node.x, node.y);
        gradient.addColorStop(0, `rgba(123, 224, 183, ${0.1 * intensity})`);
        gradient.addColorStop(1, `rgba(123, 224, 183, ${0.03 * intensity})`);

        this.ctx.strokeStyle = gradient;
        this.ctx.lineWidth = 0.7 + 0.4 * intensity;
        this.ctx.beginPath();
        this.ctx.moveTo(center.x, center.y);
        this.ctx.lineTo(node.x, node.y);
        this.ctx.stroke();

        const neighbor = arr[(index + 1) % arr.length];
        const distance = Math.hypot(node.x - neighbor.x, node.y - neighbor.y);
        if (distance < Math.min(this.width, this.height) * 0.85) {
          const secondaryIntensity = Math.min(intensity, (node.intensity + neighbor.intensity) / 2);
          this.ctx.strokeStyle = `rgba(123, 224, 183, ${0.04 * secondaryIntensity * (0.6 + timeFactor * 0.4)})`;
          this.ctx.lineWidth = 0.5;
          this.ctx.beginPath();
          this.ctx.moveTo(node.x, node.y);
          this.ctx.lineTo(neighbor.x, neighbor.y);
          this.ctx.stroke();
        }
      });

      this.ctx.restore();
    }

    private drawNodes() {
      this.nodes.forEach((node, index) => {
        const pulse = 1 + Math.sin(this.time * (0.8 + index * 0.15) + node.phase) * 0.12;
        const radius = node.radius * pulse;

        const core = index === 0 ? 0.22 : 0.15;
        const glowIntensity = core * (0.6 + node.intensity * 0.4);

        const glow = this.ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, radius * 4);
        glow.addColorStop(0, `rgba(123, 224, 183, ${glowIntensity})`);
        glow.addColorStop(1, 'rgba(123, 224, 183, 0)');
        this.ctx.fillStyle = glow;
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, radius * 3.2, 0, Math.PI * 2);
        this.ctx.fill();

        const fillOpacity = index === 0 ? 0.45 : 0.28;
        this.ctx.fillStyle = `rgba(123, 224, 183, ${fillOpacity * (0.6 + node.intensity * 0.4)})`;
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
        this.ctx.fill();
      });
    }

    public destroy() {
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
      }
      window.removeEventListener('resize', this.resizeHandler);
    }
  }

  function initValueProposition() {
    // Stelle sicher, dass no-js entfernt wurde
    document.documentElement.classList.remove('no-js');
    
    const featureCards = document.querySelectorAll('.feature-card');
    
    // Initialize network overlay for each card
    const networkAnimations: CardNetwork[] = [];
    featureCards.forEach((card) => {
      const canvas = card.querySelector('.animated-dots-canvas') as HTMLCanvasElement;
      if (canvas) {
        const animation = new CardNetwork(canvas);
        networkAnimations.push(animation);
      }
    });
    
    // Intersection Observer f체r Scroll-Animationen
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '0px'
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if (entry.isIntersecting) {
          const card = entry.target as HTMLElement;
          const delay = parseInt(card.getAttribute('data-index') || '0') * 200;
          
          setTimeout(() => {
            card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
          }, delay);
        }
      });
    }, observerOptions);

    featureCards.forEach((card) => {
      card.style.transform = 'translateY(30px)';
      observer.observe(card);
    });

    // Hover-Effekte f체r Cards
    featureCards.forEach((card) => {
      const cardWrapper = card.querySelector('.card-wrapper') as HTMLElement;
      const iconWrapper = card.querySelector('.icon-wrapper') as HTMLElement;
      
      if (cardWrapper && iconWrapper) {
        card.addEventListener('mouseenter', () => {
          cardWrapper.style.transform = 'translateY(-10px) scale(1.02)';
          iconWrapper.style.transform = 'rotate(360deg)';
        });
        
        card.addEventListener('mouseleave', () => {
          cardWrapper.style.transform = 'translateY(0) scale(1)';
          iconWrapper.style.transform = 'rotate(0deg)';
        });
      }
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initValueProposition);
  } else {
    initValueProposition();
  }
</script>

<style>
  .feature-card {
    transition: opacity 0.5s ease, transform 0.5s ease;
  }

  .card-wrapper {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .icon-wrapper {
    transition: transform 0.6s ease;
  }

  /* Animated dots canvas */
  .animated-dots-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  /* ConnectingDots Hintergrund-Effekt (vereinfacht) */
  section::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: 
      radial-gradient(circle at 20% 30%, rgba(123, 224, 183, 0.1) 0%, transparent 50%),
      radial-gradient(circle at 80% 70%, rgba(123, 224, 183, 0.1) 0%, transparent 50%),
      radial-gradient(circle at 50% 50%, rgba(123, 224, 183, 0.05) 0%, transparent 50%);
    opacity: 0.3;
    pointer-events: none;
  }

  /* Fallback: Wenn JavaScript nicht l채uft, zeige Content trotzdem */
  .no-js .feature-card {
    opacity: 1 !important;
    transform: none !important;
  }
</style>

